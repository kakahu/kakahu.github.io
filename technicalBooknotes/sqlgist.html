<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<style>
h1,
h2,
h3,
h4,
h5,
h6,
p,
blockquote {
    margin: 0;
    padding: 0;
}
body {
    font-family: "Helvetica Neue", Helvetica, "Hiragino Sans GB", Arial, sans-serif;
    font-size: 13px;
    line-height: 18px;
    color: #737373;
    background-color: white;
    margin: 10px 13px 10px 13px;
}
table {
	margin: 10px 0 15px 0;
	border-collapse: collapse;
}
td,th {	
	border: 1px solid #ddd;
	padding: 3px 10px;
}
th {
	padding: 5px 10px;	
}

a {
    color: #0069d6;
}
a:hover {
    color: #0050a3;
    text-decoration: none;
}
a img {
    border: none;
}
p {
    margin-bottom: 9px;
}
h1,
h2,
h3,
h4,
h5,
h6 {
    color: #404040;
    line-height: 36px;
}
h1 {
    margin-bottom: 18px;
    font-size: 30px;
}
h2 {
    font-size: 24px;
}
h3 {
    font-size: 18px;
}
h4 {
    font-size: 16px;
}
h5 {
    font-size: 14px;
}
h6 {
    font-size: 13px;
}
hr {
    margin: 0 0 19px;
    border: 0;
    border-bottom: 1px solid #ccc;
}
blockquote {
    padding: 13px 13px 21px 15px;
    margin-bottom: 18px;
    font-family:georgia,serif;
    font-style: italic;
}
blockquote:before {
    content:"\201C";
    font-size:40px;
    margin-left:-10px;
    font-family:georgia,serif;
    color:#eee;
}
blockquote p {
    font-size: 14px;
    font-weight: 300;
    line-height: 18px;
    margin-bottom: 0;
    font-style: italic;
}
code, pre {
    font-family: Monaco, Andale Mono, Courier New, monospace;
}
code {
    background-color: #fee9cc;
    color: rgba(0, 0, 0, 0.75);
    padding: 1px 3px;
    font-size: 12px;
    -webkit-border-radius: 3px;
    -moz-border-radius: 3px;
    border-radius: 3px;
}
pre {
    display: block;
    padding: 14px;
    margin: 0 0 18px;
    line-height: 16px;
    font-size: 11px;
    border: 1px solid #d9d9d9;
    white-space: pre-wrap;
    word-wrap: break-word;
}
pre code {
    background-color: #fff;
    color:#737373;
    font-size: 11px;
    padding: 0;
}
sup {
    font-size: 0.83em;
    vertical-align: super;
    line-height: 0;
}
* {
	-webkit-print-color-adjust: exact;
}
@media screen and (min-width: 914px) {
    body {
        width: 854px;
        margin:10px auto;
    }
}
@media print {
	body,code,pre code,h1,h2,h3,h4,h5,h6 {
		color: black;
	}
	table, pre {
		page-break-inside: avoid;
	}
}
</style>
<title>SQL 使用简要</title>

</head>
<body>
<h1>SQL 使用简要</h1>

<p><a href="../index.html">返回首页</a></p>

<p><a href="./technicalBooknotesIndex.html">返回技术书籍笔记</a></p>

<h2>SQL的基本概念</h2>

<p>SQL的目录结构基本如下：</p>

<ul>
<li>最上层是database/Schema</li>
<li>中间是Table</li>
<li>最下一层是View,具体的数据结构</li>
</ul>


<h3>mysql 执行脚本的方法：</h3>

<p>在命令行中使用
<code>mysql &lt; script.sql -u root -p</code>
在mysql Shell中使用
<code>source script.sql</code>
或者 <code>.\ script.sql</code></p>

<h2>SQL语句</h2>

<p>在数据库上的操作大部分由SQL语句完成。SQL语句对大小写不敏感。</p>

<p>可以把 SQL 分为两个部分：数据操作语言 (DML) 和 数据定义语言 (DDL)。</p>

<p>SQL (结构化查询语言)是用于执行查询的语法。但是 SQL 语言也包含用于更新、插入和删除记录的语法。</p>

<p>查询和更新指令构成了 SQL 的 DML 部分：</p>

<ul>
<li>SELECT - 从数据库表中获取数据</li>
<li>UPDATE - 更新数据库表中的数据</li>
<li>DELETE - 从数据库表中删除数据</li>
<li>INSERT INTO - 向数据库表中插入数据</li>
</ul>


<p>SQL 的数据定义语言 (DDL) 部分使我们有能力创建或删除表格。我们也可以定义索引（键），规定表之间的链接，以及施加表间的约束。</p>

<p>SQL 中最重要的 DDL 语句:</p>

<ul>
<li>CREATE DATABASE - 创建新数据库</li>
<li>ALTER DATABASE - 修改数据库</li>
<li>CREATE TABLE - 创建新表</li>
<li>ALTER TABLE - 变更（改变）数据库表</li>
<li>DROP TABLE - 删除表</li>
<li>CREATE INDEX - 创建索引（搜索键）</li>
<li>DROP INDEX - 删除索引</li>
</ul>


<h3>Select 语句</h3>

<p>SQL SELECT 语法</p>

<p><code>SELECT 列名称 FROM 表名称</code></p>

<p>或者</p>

<p><code>SELECT * FROM 表名称</code></p>

<p><code>SELECT DISTINCT 列名称 FROM 表名称</code></p>

<p><code>SELECT 列名称 FROM 表名称 WHERE 列 运算符 值</code>
eg. <code>SELECT * FROM Persons WHERE City='Beijing'</code></p>

<p><code>SELECT * FROM Persons WHERE FirstName='Thomas' AND LastName='Carter'</code></p>

<p><code>SELECT * FROM Persons WHERE firstname='Thomas' OR lastname='Carter'</code></p>

<h3>ORDER BY 子句</h3>

<p>以字母顺序显示公司名称：
<code>SELECT Company, OrderNumber FROM Orders ORDER BY Company</code></p>

<p><code>SELECT Company, OrderNumber FROM Orders ORDER BY Company DESC</code></p>

<p><code>SELECT Company, OrderNumber FROM Orders ORDER BY Company DESC, OrderNumber ASC</code> 先按照company逆序，再按OrderNumber顺序。</p>

<h3>INSERT INTO 语句</h3>

<p>INSERT INTO 语句用于向表格中插入新的行。</p>

<p><code>INSERT INTO 表名称 VALUES (值1, 值2,....)</code></p>

<p>我们也可以指定所要插入数据的列：</p>

<p><code>INSERT INTO table_name (列1, 列2,...) VALUES (值1, 值2,....)</code></p>

<p><code>INSERT INTO Persons (LastName, Address) VALUES ('Wilson', 'Champs-Elysees')</code></p>

<h3>Update 语句</h3>

<p>Update 语句用于修改表中的数据。</p>

<p><code>UPDATE 表名称 SET 列名称 = 新值 WHERE 列名称 = 某值</code></p>

<p><code>UPDATE Person SET FirstName = 'Fred' WHERE LastName = 'Wilson'</code></p>

<h3>DELETE 语句</h3>

<p><code>DELETE FROM 表名称 WHERE 列名称 = 值</code></p>

<p><code>DELETE FROM Person WHERE LastName = 'Wilson'</code></p>

<p>删除所有行: 可以在不删除表的情况下删除所有的行。这意味着表的结构、属性和索引都是完整的：</p>

<p><code>DELETE FROM table_name</code></p>

<p>或者：</p>

<p><code>DELETE * FROM table_name</code></p>

<h3>TOP 语句</h3>

<p><code>SELECT TOP number|percent column_name(s)</code></p>

<p><code>FROM table_name</code></p>

<p>MySQL 和 Oracle 中的 SQL SELECT TOP 是等价的</p>

<p>MySQL 语法</p>

<p><code>SELECT column_name(s)</code></p>

<p><code>FROM table_name</code></p>

<p><code>LIMIT number</code></p>

<p>例子</p>

<p><code>SELECT *</code></p>

<p><code>FROM Persons</code></p>

<p><code>LIMIT 5</code></p>

<h3>Like语句</h3>

<p>SQL LIKE 操作符语法</p>

<p><code>SELECT column_name(s)</code></p>

<p><code>FROM table_name</code></p>

<p><code>WHERE column_name LIKE pattern</code></p>

<p>从上面的 "Persons" 表中选取居住在以 "N" 开始的城市里的人：</p>

<p>我们可以使用下面的 SELECT 语句：</p>

<p><code>SELECT * FROM Persons</code>
<code>WHERE City LIKE 'N%'</code></p>

<h3>通配符</h3>

<p>通配符   描述
%   替代一个或多个字符</p>

<p>_   仅替代一个字符</p>

<p>[charlist]  字符列中的任何单一字符</p>

<p>[^charlist] 或者 [!charlist] 不在字符列中的任何单一字符</p>

<h3>IN 语法</h3>

<p><code>SELECT column_name(s)</code></p>

<p><code>FROM table_name</code></p>

<p><code>WHERE column_name IN (value1,value2,...)</code></p>

<h3>BETWEEN 语法</h3>

<p><code>SELECT column_name(s)</code></p>

<p><code>FROM table_name</code></p>

<p><code>WHERE column_name</code></p>

<p><code>BETWEEN value1 AND value2</code>
至于会不会包括边界值需要看具体数据库情况</p>

<h3>Alias</h3>

<p>表的 SQL Alias 语法</p>

<p><code>SELECT column_name(s)</code></p>

<p><code>FROM table_name</code></p>

<p><code>AS alias_name</code></p>

<p>列的 SQL Alias 语法</p>

<p><code>SELECT column_name AS alias_name</code></p>

<p><code>FROM table_name</code></p>

<h3>join</h3>

<p>用于根据两个或多个表中的列之间的关系，从这些表中查询数据。</p>

<p><code>SELECT Persons.LastName, Persons.FirstName, Orders.OrderNo</code></p>

<p><code>FROM Persons, Orders</code></p>

<p><code>WHERE Persons.Id_P = Orders.Id_P</code></p>

<p>可以用下面来替代：</p>

<p><code>SELECT Persons.LastName, Persons.FirstName, Orders.OrderNo</code></p>

<p><code>FROM Persons</code></p>

<p><code>INNER JOIN Orders</code></p>

<p><code>ON Persons.Id_P = Orders.Id_P</code></p>

<p><code>ORDER BY Persons.LastName</code></p>

<h3>不同的 SQL JOIN</h3>

<p>除了我们在上面的例子中使用的 INNER JOIN（内连接），我们还可以使用其他几种连接。</p>

<p>下面列出了您可以使用的 JOIN 类型，以及它们之间的差异。</p>

<ul>
<li>JOIN: 如果表中有至少一个匹配，则返回行</li>
<li>LEFT JOIN: 即使右表中没有匹配，也从左表返回所有的行</li>
<li>RIGHT JOIN: 即使左表中没有匹配，也从右表返回所有的行</li>
<li>FULL JOIN: 只要其中一个表中存在匹配，就返回行</li>
</ul>


<h3>UNION 操作符</h3>

<p>UNION 操作符用于合并两个或多个 SELECT 语句的结果集。</p>

<p>请注意，UNION 内部的 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条 SELECT 语句中的列的顺序必须相同。</p>

<p>SQL UNION 语法</p>

<p><code>SELECT column_name(s) FROM table_name1</code></p>

<p><code>UNION</code></p>

<p><code>SELECT column_name(s) FROM table_name2</code></p>

<p>注释：默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL。</p>

<h3>INTO 语句</h3>

<p>SELECT INTO 语句从一个表中选取数据，然后把数据插入另一个表中。</p>

<p>SELECT INTO 语句常用于创建表的备份复件或者用于对记录进行存档。</p>

<p>可以把所有的列插入新表：</p>

<p><code>SELECT *</code></p>

<p><code>INTO new_table_name [IN externaldatabase]</code></p>

<p><code>FROM old_tablename</code></p>

<p>或者只把希望的列插入新表：</p>

<p><code>SELECT column_name(s)</code></p>

<p><code>INTO new_table_name [IN externaldatabase]</code></p>

<p><code>FROM old_tablename</code></p>

<p><code>SELECT LastName,Firstname</code></p>

<p><code>INTO Persons_backup</code></p>

<p><code>FROM Persons</code></p>

<p><code>WHERE City='Beijing'</code></p>

<p><code>SELECT Persons.LastName,Orders.OrderNo</code></p>

<p><code>INTO Persons_Order_Backup</code></p>

<p><code>FROM Persons</code></p>

<p><code>INNER JOIN Orders</code></p>

<p><code>ON Persons.Id_P=Orders.Id_P</code></p>

<h3>CREATE DATABASE 语法</h3>

<p><code>CREATE DATABASE database_name</code></p>

<h3>CREATE TABLE 语法</h3>

<pre><code>CREATE TABLE 表名称
(
列名称1 数据类型,
列名称2 数据类型,
列名称3 数据类型,
....
)
</code></pre>

<table>
<thead>
<tr>
<th> 数据类型 </th>
<th align="center"> 描述 </th>
</tr>
</thead>
<tbody>
<tr>
<td> integer(size), int(size), smallint(size), tinyint(size)    </td>
<td align="center"> 仅容纳整数。在括号内规定数字的最大位数    </td>
</tr>
<tr>
<td> decimal(size,d), numeric(size,d)    </td>
<td align="center"> 容纳带有小数的数字。"size" 规定数字的最大位数。"d" 规定小数点右侧的最大位数  </td>
</tr>
<tr>
<td> char(size)    </td>
<td align="center"> 容纳固定长度的字符串（可容纳字母、数字以及特殊字符）。在括号中规定字符串的长度  </td>
</tr>
<tr>
<td> varchar(size)    </td>
<td align="center"> 容纳可变长度的字符串（可容纳字母、数字以及特殊的字符）。在括号中规定字符串的最大长度  </td>
</tr>
<tr>
<td> date(yyyymmdd)    </td>
<td align="center"> 容纳日期  </td>
</tr>
</tbody>
</table>


<h3>约束</h3>

<ul>
<li><p>NOT NULL强制约束不接受NULL值</p></li>
<li><p>UNIQUE 约束唯一标识数据库表中的每条记录。</p>

<p>  UNIQUE 和 PRIMARY KEY 约束均为列或列集合提供了唯一性的保证。</p>

<p>  PRIMARY KEY 拥有自动定义的 UNIQUE 约束。</p>

<p>  请注意，每个表可以有多个 UNIQUE 约束，但是每个表只能有一个 PRIMARY KEY 约束。</p></li>
<li><p>PRIMARY KEY 约束唯一标识数据库表中的每条记录。</p>

<p>  主键必须包含唯一的值。</p>

<p>  主键列不能包含 NULL 值。</p>

<p>  每个表都应该有一个主键，并且每个表只能有一个主键。</p></li>
<li><p>一个表中的 FOREIGN KEY 指向另一个表中的 PRIMARY KEY</p></li>
</ul>


<p><code>MYsql</code></p>

<pre><code>CREATE TABLE Orders

(

Id_O int NOT NULL,

OrderNo int NOT NULL,

Id_P int,

PRIMARY KEY (Id_O),

FOREIGN KEY (Id_P) REFERENCES Persons(Id_P)

)
</code></pre>

<ul>
<li><p>CHECK 约束</p>

<p>  CHECK 约束用于限制列中的值的范围。</p>

<p>  如果对单个列定义 CHECK 约束，那么该列只允许特定的值。</p>

<p>  如果对一个表定义 CHECK 约束，那么此约束会在特定的列中对值进行限制。</p></li>
</ul>


<p><code>  My SQL:</code></p>

<pre><code>CREATE TABLE Persons

(

Id_P int NOT NULL,

LastName varchar(255) NOT NULL,

FirstName varchar(255), 

Address varchar(255),

City varchar(255),

CHECK (Id_P&gt;0)

)
</code></pre>

<ul>
<li>DEFAULT 约束</li>
</ul>


<p>DEFAULT 约束用于向列中插入默认值。</p>

<p>如果没有规定其他的值，那么会将默认值添加到所有的新记录。</p>

<p><code>Mysql</code></p>

<pre><code>CREATE TABLE Persons
(
Id_P int NOT NULL,
LastName varchar(255) NOT NULL,
FirstName varchar(255),
Address varchar(255),
City varchar(255) DEFAULT 'Sandnes'
)
</code></pre>

<ul>
<li>CREATE INDEX 语句</li>
</ul>


<p>可以在表中创建索引，以便更加快速高效地查询数据。</p>

<p>用户无法看到索引，它们只能被用来加速搜索/查询。</p>

<p>注释：更新一个包含索引的表需要比更新一个没有索引的表更多的时间，这是由于索引本身也需要更新。因此，理想的做法是仅仅在常常被搜索的列（以及表）上面创建索引。</p>

<pre><code>CREATE INDEX index_name
ON table_name (column_name)
</code></pre>

<p>本例会创建一个简单的索引，名为 "PersonIndex"，在 Person 表的 LastName 列：</p>

<pre><code>CREATE INDEX PersonIndex
ON Person (LastName) 
</code></pre>

<p>如果您希望以降序索引某个列中的值，您可以在列名称之后添加保留字 DESC：</p>

<pre><code>CREATE INDEX PersonIndex
ON Person (LastName DESC) 
</code></pre>

<p>假如您希望索引不止一个列，您可以在括号中列出这些列的名称，用逗号隔开：</p>

<pre><code>CREATE INDEX PersonIndex
ON Person (LastName, FirstName)
</code></pre>

<ul>
<li><p>DROP 和 TRUNCATE语句</p>

<ul>
<li><p>DROP TABLE 语句用于删除表（表的结构、属性以及索引也会被删除）</p></li>
<li><p>DROP DATABASE 语句用于删除数据库</p></li>
<li><p>如果我们仅仅需要除去表内的数据，但并不删除表本身，那么我们该如何做呢？</p>

<p>  请使用 TRUNCATE TABLE 命令（仅仅删除表格中的数据）：</p>

<p>  TRUNCATE TABLE 表名称</p></li>
</ul>
</li>
<li><p>ALTER TABLE 语句</p></li>
</ul>


<p>ALTER TABLE 语句用于在已有的表中添加、修改或删除列。</p>

<p>如需在表中添加列，请使用下列语法:</p>

<pre><code>ALTER TABLE table_name
ADD column_name datatype
</code></pre>

<p>要删除表中的列，请使用下列语法：</p>

<pre><code>ALTER TABLE table_name 
DROP COLUMN column_name
</code></pre>

<p>要改变表中列的数据类型，请使用下列语法：</p>

<pre><code>ALTER TABLE table_name
ALTER COLUMN column_name datatype
</code></pre>

<h3>AUTO INCREMENT 字段</h3>

<p>我们通常希望在每次插入新记录时，自动地创建主键字段的值。</p>

<p>我们可以在表中创建一个 auto-increment 字段。</p>

<p>下列 SQL 语句把 "Persons" 表中的 "P_Id" 列定义为 auto-increment 主键：</p>

<pre><code>CREATE TABLE Persons
(
P_Id int NOT NULL AUTO_INCREMENT,
LastName varchar(255) NOT NULL,
FirstName varchar(255),
Address varchar(255),
City varchar(255),
PRIMARY KEY (P_Id)
)
</code></pre>

<h3>View视图</h3>

<p>在 SQL 中，视图是基于 SQL 语句的结果集的可视化的表。</p>

<p>视图包含行和列，就像一个真实的表。视图中的字段就是来自一个或多个数据库中的真实的表中的字段。我们可以向视图添加 SQL 函数、WHERE 以及 JOIN 语句，我们也可以提交数据，就像这些来自于某个单一的表。</p>

<p>注释：数据库的设计和结构不会受到视图中的函数、where 或 join 语句的影响。</p>

<pre><code>SQL CREATE VIEW 语法
CREATE VIEW view_name AS
SELECT column_name(s)
FROM table_name
WHERE condition
</code></pre>

<p>注释：视图总是显示最近的数据。每当用户查询视图时，数据库引擎通过使用 SQL 语句来重建数据。</p>

<p>Northwind 样本数据库的另一个视图会选取 Products 表中所有单位价格高于平均单位价格的产品：</p>

<pre><code>CREATE VIEW [Products Above Average Price] AS
SELECT ProductName,UnitPrice
FROM Products
WHERE UnitPrice&gt;(SELECT AVG(UnitPrice) FROM Products) 
</code></pre>

<h3>NULL</h3>

<p>我们必须使用 IS NULL 操作符：</p>

<pre><code>SELECT LastName,FirstName,Address FROM Persons
WHERE Address IS （NOT）NULL
</code></pre>

<p>在 MySQL 中，我们可以使用 IFNULL() 函数，就像这样：</p>

<pre><code>SELECT ProductName,UnitPrice*(UnitsInStock+IFNULL(UnitsOnOrder,0))
FROM Products
</code></pre>

<p>或者我们可以使用 COALESCE() 函数，就像这样：</p>

<pre><code>SELECT ProductName,UnitPrice*(UnitsInStock+COALESCE(UnitsOnOrder,0))
FROM Products
</code></pre>

<h2>MySQL 函数</h2>

<h3>avg函数</h3>

<p>AVG 函数返回数值列的平均值。NULL 值不包括在计算中。</p>

<p>SQL AVG() 语法</p>

<pre><code>SELECT AVG(column_name) FROM table_name
</code></pre>

<p>希望找到 OrderPrice 值高于 OrderPrice 平均值的客户。
我们使用如下 SQL 语句：</p>

<pre><code>SELECT Customer FROM Orders
WHERE OrderPrice&gt;(SELECT AVG(OrderPrice) FROM Orders)
</code></pre>

<h3>COUNT 函数</h3>

<p>COUNT(column_name) 函数返回指定列的值的数目（NULL 不计入）：</p>

<pre><code>SELECT COUNT(column_name) FROM table_name
</code></pre>

<h3>First、Last函数</h3>

<pre><code>SELECT FIRST(column_name) FROM table_name
SELECT LAST(column_name) FROM table_name
</code></pre>

<h3>Max、Min函数</h3>

<pre><code>SELECT MAX(column_name) FROM table_name
SELECT MIN(column_name) FROM table_name
</code></pre>

<h3>SUM 函数</h3>

<pre><code>SELECT SUM(column_name) FROM table_name
</code></pre>

<h3>GROUP BY函数</h3>

<p>SQL GROUP BY 语法</p>

<pre><code>SELECT column_name, aggregate_function(column_name)
FROM table_name 
WHERE column_name operator value
GROUP BY column_name
</code></pre>

<h3>HAVING 函数</h3>

<p>在 SQL 中增加 HAVING 子句原因是，WHERE 关键字无法与合计函数一起使用。
SQL HAVING 语法</p>

<pre><code>SELECT column_name, aggregate_function(column_name)
FROM table_name
WHERE column_name operator value
GROUP BY column_name
HAVING aggregate_function(column_name) operator value
</code></pre>

<p>举例：</p>

<pre><code>SELECT Customer,SUM(OrderPrice) FROM Orders
WHERE Customer='Bush' OR Customer='Adams'
GROUP BY Customer
HAVING SUM(OrderPrice)&gt;1500
</code></pre>

<h3>MID（）函数</h3>

<p>MID() 函数</p>

<p>MID 函数用于从文本字段中提取字符。</p>

<p>SQL MID() 语法</p>

<pre><code>SELECT MID(column_name,start[,length]) FROM table_name
</code></pre>

<h3>LEN() 函数</h3>

<p>LEN 函数返回文本字段中值的长度。</p>

<p>SQL LEN() 语法</p>

<pre><code>SELECT LEN(column_name) FROM table_name
</code></pre>

<h3>ROUND() 函数</h3>

<p>ROUND 函数用于把数值字段舍入为指定的小数位数。</p>

<p>SQL ROUND() 语法</p>

<pre><code>SELECT ROUND(column_name,decimals) FROM table_name
</code></pre>

<p>如下 SQL 语句：</p>

<pre><code>SELECT ProductName, ROUND(UnitPrice,0) as UnitPrice FROM Products
</code></pre>

<h3>NOW 函数</h3>

<p>返回当前的日期和时间。</p>

<p>SQL NOW() 语法</p>

<pre><code>SELECT NOW() FROM table_name
</code></pre>

<p>使用如下 SQL 语句：
    SELECT ProductName, UnitPrice, Now() as PerDate FROM Products</p>

<h3>FORMAT() 函数</h3>

<p>FORMAT 函数用于对字段的显示进行格式化。</p>

<p>SQL FORMAT() 语法</p>

<pre><code>SELECT FORMAT(column_name,format) FROM table_name
</code></pre>

<p>如下 SQL 语句：</p>

<pre><code>SELECT ProductName, UnitPrice, FORMAT(Now(),'YYYY-MM-DD') as PerDate
FROM Products
</code></pre>
</body>
</html>