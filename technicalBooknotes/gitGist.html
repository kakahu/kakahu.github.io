<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<style>
h1,
h2,
h3,
h4,
h5,
h6,
p,
blockquote {
    margin: 0;
    padding: 0;
}
body {
    font-family: "Helvetica Neue", Helvetica, "Hiragino Sans GB", Arial, sans-serif;
    font-size: 13px;
    line-height: 18px;
    color: #737373;
    background-color: white;
    margin: 10px 13px 10px 13px;
}
table {
	margin: 10px 0 15px 0;
	border-collapse: collapse;
}
td,th {	
	border: 1px solid #ddd;
	padding: 3px 10px;
}
th {
	padding: 5px 10px;	
}

a {
    color: #0069d6;
}
a:hover {
    color: #0050a3;
    text-decoration: none;
}
a img {
    border: none;
}
p {
    margin-bottom: 9px;
}
h1,
h2,
h3,
h4,
h5,
h6 {
    color: #404040;
    line-height: 36px;
}
h1 {
    margin-bottom: 18px;
    font-size: 30px;
}
h2 {
    font-size: 24px;
}
h3 {
    font-size: 18px;
}
h4 {
    font-size: 16px;
}
h5 {
    font-size: 14px;
}
h6 {
    font-size: 13px;
}
hr {
    margin: 0 0 19px;
    border: 0;
    border-bottom: 1px solid #ccc;
}
blockquote {
    padding: 13px 13px 21px 15px;
    margin-bottom: 18px;
    font-family:georgia,serif;
    font-style: italic;
}
blockquote:before {
    content:"\201C";
    font-size:40px;
    margin-left:-10px;
    font-family:georgia,serif;
    color:#eee;
}
blockquote p {
    font-size: 14px;
    font-weight: 300;
    line-height: 18px;
    margin-bottom: 0;
    font-style: italic;
}
code, pre {
    font-family: Monaco, Andale Mono, Courier New, monospace;
}
code {
    background-color: #fee9cc;
    color: rgba(0, 0, 0, 0.75);
    padding: 1px 3px;
    font-size: 12px;
    -webkit-border-radius: 3px;
    -moz-border-radius: 3px;
    border-radius: 3px;
}
pre {
    display: block;
    padding: 14px;
    margin: 0 0 18px;
    line-height: 16px;
    font-size: 11px;
    border: 1px solid #d9d9d9;
    white-space: pre-wrap;
    word-wrap: break-word;
}
pre code {
    background-color: #fff;
    color:#737373;
    font-size: 11px;
    padding: 0;
}
sup {
    font-size: 0.83em;
    vertical-align: super;
    line-height: 0;
}
* {
	-webkit-print-color-adjust: exact;
}
@media screen and (min-width: 914px) {
    body {
        width: 854px;
        margin:10px auto;
    }
}
@media print {
	body,code,pre code,h1,h2,h3,h4,h5,h6 {
		color: black;
	}
	table, pre {
		page-break-inside: avoid;
	}
}
</style>
<title>Git 基本操作</title>

</head>
<body>
<h1>Git 基本操作</h1>

<p><a href="../index.html">返回首页</a></p>

<p><a href="./technicalBooknotesIndex.html">返回技术书籍笔记</a></p>

<p>git本地新建目录，push到远程仓库的方法：</p>

<ul>
<li>mkdir gitRepo</li>
<li>cd gitRepo</li>
<li>git init  #初始化本地仓库</li>
<li>git add xxx  #添加要push到远程仓库的文件或文件夹</li>
<li>git commit -m 'first commit'  #提交zhiqadd的文件</li>
<li>git remote add origin https://github.com/yourgithubID/gitRepo.git  #建立远程仓库</li>
<li>git push -u origin master #将本地仓库push到远程仓库</li>
</ul>


<p>p.s. : 需要先在github手动创建repo</p>

<h3>Git详细操作</h3>

<p>Git是一个仓库，在本仓库及子目录下的文件才可以被检索到。</p>

<p>git add命令可以将文件加入到仓库中，例子：git add readme.txt</p>

<p>git add —all</p>

<p>git commit 讲文件提交到库，例子：git commit -m “wrote a readme file."
-m 后面表示提交的说明。</p>

<p>git status 显示仓库当前的状态</p>

<p>git diff readme.txt 查看修改内容</p>

<p>git log查看历史记录</p>

<p>git reset —hard XXX 把当前版本回退到XXX</p>

<p>git reflog 来查看每一次命令和相应的SHA1值，用来调整版本</p>

<p>我们把文件往Git版本库里添加的时候，是分两步执行的：</p>

<ul>
<li>第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；</li>
<li>第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。</li>
</ul>


<p>每次修改，如果不add到暂存区，那就不会加入到commit中</p>

<p>git add将修改放入暂存区，还没有新生成一个版本，commit之后生成一个版本，再push之后才会在向公共版本上提交更新</p>

<p><code>Changes not staged for commit:</code> 表示文件在工作区，可以add了</p>

<p><code>Changes to be committed:</code> 表示文件在暂存区，可以commit了</p>

<p>命令git checkout -- readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况：</p>

<ul>
<li>一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</li>
<li>一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</li>
</ul>


<p>总之，就是让这个文件回到最近一次git commit或git add时的状态。</p>

<p>用命令git reset HEAD file可以把暂存区的修改撤销掉（unstage），重新放回工作区</p>

<p><code>$ git reset HEAD readme.txt</code></p>

<p><code>Unstaged changes after reset:
M       readme.txt</code></p>

<p>上面从暂存区回到了工作区。</p>

<p>综上，对于已经添加在暂存区的文件，撤回过程为：</p>

<ul>
<li><p>git checkout — readme.txt 退回到刚加入暂存区时的状态</p></li>
<li><p>git reset HEAD file，把暂存区清空</p></li>
<li><p>git checkout — readme.txt 丢弃工作区的修改</p></li>
</ul>


<p>删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：</p>

<p><code>$ git checkout -- test.txt</code></p>

<p>git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p>

<p>要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git；</p>

<p>关联后，使用命令<code>git push -u origin master</code>第一次推送master分支的所有内容；
此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改；</p>

<h3>分支管理</h3>

<p>我们创建dev分支，然后切换到dev分支：</p>

<p><code>$ git checkout -b dev</code></p>

<p><code>Switched to a new branch 'dev'</code></p>

<p>git checkout命令加上-b参数表示创建并切换，相当于以下两条命令：</p>

<p><code>$ git branch dev</code></p>

<p><code>$ git checkout dev</code></p>

<p><code>Switched to branch 'dev'</code></p>

<p>然后，用git branch命令查看当前分支：</p>

<p><code>$ git branch</code></p>

<p><code>* dev</code></p>

<p><code>master</code></p>

<p>然后，我们就可以在dev分支上正常提交，比如对readme.txt做个修改，加上一行：</p>

<p>Creating a new branch is quick.</p>

<p>然后提交：</p>

<p><code>$ git add readme.txt</code></p>

<p><code>$ git commit -m "branch test"</code></p>

<p><code>[dev fec145a] branch test</code></p>

<p><code>1 file changed, 1 insertion(+)</code></p>

<p>现在，dev分支的工作完成，我们就可以切换回master分支：</p>

<p><code>$ git checkout master</code></p>

<p><code>Switched to branch 'master'</code></p>

<p>切换回master分支后，再查看一个readme.txt文件，刚才添加的内容不见了！因为那个提交是在dev分支上，而master分支此刻的提交点并没有变</p>

<p><code>git merge dev</code>将dev分支合并到Master上</p>

<p><code>git branch -d dev</code>删除dev分支</p>

<p>查看分支：git branch</p>

<p>创建分支：git branch <name></p>

<p>切换分支：git checkout <name></p>

<p>创建+切换分支：git checkout -b <name></p>

<p>合并某分支到当前分支：git merge <name></p>

<p>删除分支：git branch -d <name></p>

<p>合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。</p>

<p>首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p>

<p>那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；</p>

<p>你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。</p>

<p>所以，团队合作的分支看起来就像这样：</p>

<ul>
<li>git stash 可以把工作现场储藏起来</li>
<li>git stash list可以看到所有工作现场</li>
<li>git stash apply可以恢复现场，但stash的内容不删除，用git stash drop来删除</li>
<li>git stash pop可以恢复同时删除</li>
<li>git stash apply stash@{0}恢复指定位置的工作现场</li>
</ul>


<h3>合作管理</h3>

<p>开发一个新feature，最好新建一个分支；
如果要丢弃一个没有被合并过的分支，可以通过git branch -D <name>强行删除。</p>

<p>将某个分支推送到远程分支上 git push origin XXX</p>

<p>删除远程上的一个分支
git push origin --delete <branchName></p>

<p>设置dev和origin/dev的链接：</p>

<p><code>$ git branch --set-upstream dev origin/dev</code></p>

<p><code>Branch dev set up to track remote branch dev from origin.</code></p>

<p>再pull：</p>

<p><code>$ git pull</code></p>

<p><code>Auto-merging hello.py</code></p>

<p><code>CONFLICT (content): Merge conflict in hello.py</code></p>

<p><code>Automatic merge failed; fix conflicts and then commit the result.</code></p>

<p>这回git pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样。解决后，提交，再push：</p>

<p><code>$ git commit -m "merge &amp; fix hello.py"</code></p>

<p><code>[dev adca45d] merge &amp; fix hello.py</code></p>

<p><code>$ git push origin dev</code></p>

<p><code>Counting objects: 10, done.</code></p>

<p><code>Delta compression using up to 4 threads.</code></p>

<p><code>Compressing objects: 100% (5/5), done.</code></p>

<p><code>Writing objects: 100% (6/6), 747 bytes, done.</code></p>

<p><code>Total 6 (delta 0), reused 0 (delta 0)</code></p>

<p><code>To git@github.com:michaelliao/learngit.git</code></p>

<p> <code> 291bea8..adca45d  dev -&gt; dev</code></p>

<h3>Tag功能</h3>

<p>命令git tag <name>用于新建一个标签，默认为HEAD，也可以指定一个commit id；</p>

<ul>
<li><p>git tag -a <tagname> -m "blablabla..."可以指定标签信息；</p></li>
<li><p>git tag -s <tagname> -m "blablabla..."可以用PGP签名标签；</p></li>
<li><p>命令git tag可以查看所有标签。</p></li>
<li><p>忽略某些文件时，需要编写.gitignore；</p></li>
</ul>


<p>.gitignore文件本身要放到版本库里，并且可以对.gitignore做版本管理！</p>
</body>
</html>